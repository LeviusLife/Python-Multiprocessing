"""
Name: Terryon Larkins
Date: October 14th, 2024
Assignment: Assignment 3: Computing Prime Triplet with Multiprocessing
Due Date: October 14th, 11:59pm
About this project: The goal of this assignment was to calculate the prime triplet of a given number with parallel processing. If a number is prime then
there is a chance that a prime triplet exists with this number. But there is no guarantee that the given number has a related
prime triplet. In order to complete this task, I used the given reference code as the base for this assignment. The code below is similar
to the given code except there are two new functions and the last section of code, related to creating the prime triplet, has been modified.
The two new functions are the sieve functions. One version is parallelized in order to help build the prime list associated with the given
number, while the other is not parallelized and is exclusively used to find the list of prime numbers between the given number and that number
plus 100,000. The code in the last portion was changed to loop through the prime list (somethingBig) and then check the difference between the third and first
entry of the prime triplet being made. If the numbers don't have a difference of six the for loop continues until it finds one.
After that is over, the parallelized sieve function is tasked with building the rest of the prime list, primesCopy. The main process
creates the small prime list and then each worker is tasked with making their share of the list with said small list of primes. This setup
allows the main process to contribute and lighten the load on the child processes, and minimizes the amount of communication between message queues.
To be more transparent about the beginning of the code, I initiaaly use isPrime and makePrimeList in order to
make a small portion of the primeList, primesCopy. Using the method of trial division in isPrime is fine for smaller numbers but for exceptionally large
numbers this method will take too long even with the help of a parallelized function. , 
Assumptions: One assumption that I made is that the user will give valid integers when asked for a number to generate a prime triplet. If any other type of input is given then the program will not work at all. Another assumption is that adding 100,000 to the given number would give enough wiggle room to find the prime triplet of numbers in between 1 trillion and 5 trillion.
All work below was performed solely by Terryon Larkins.
I used code generated by an AI tool. Specifically, I used it to help me write and understand the segmented sieve algorithm. Before I was aware that...



Timing results in linprog:

Input n: 1000000000000
The smallest triplet larger than 1000000000000 is (1000000005073, 1000000005077, 1000000005079)

1 worker: 1.1297178268432617 seconds
2 workers: 0.7986211776733398 seconds 
4 workers: 0.5578138828277588 seconds
8 workers: 0.4238009452819824 seconds 



Input n: 3000000000000
The smallest triplet larger than 3000000000000 is (3000000004447, 3000000004451, 3000000004453)

1 worker: 2.122405767440796 seconds
2 workers: 1.4552218914031982 seconds 
4 workers: 1.042072057723999 seconds 
8 workers: 0.7366499900817871 seconds 


"""





import math
import time
import multiprocessing
import random
from random import randint
import sys

primesCopy = [2, 3, 5]


def makePrimeList(n):
    for i in range(6, n):
        if (isPrime(i)):
            primesCopy.append(i)


def isPrime(n):
    """
    This function assumes that primes is sorted and includes
    all prime numbers up to at least int(math.sqrt(n)) + 1
    """
    
    i=0
    b = int(math.sqrt(n)) + 1
    pLen = len(primesCopy)
    while i < pLen and (primesCopy[i] < b):
        if n % primesCopy[i] == 0:
            return False
        i = i + 1
    return True


def sieve_with_known_primes():
    """ Uses known primes up to sqrt(end) to sieve the range [start, end] """
    

    start, end = tQueue.get()
    sieve = [True] * (end - start + 1)

    for prime in primesCopy:
        # Find the first multiple of prime in the [start, end] range
        multiple = max(prime * prime, (start + prime - 1) // prime * prime)
        
        # Mark off multiples of prime in the sieve array
        for i in range(multiple, end + 1, prime):
            sieve[i - start] = False

    # Return the list of primes in the range [start, end]
    #return [num for num, is_prime in enumerate(sieve, start=start) if is_prime]
    rQueue.put([num for num, is_prime in enumerate(sieve, start=start) if is_prime])

def sieve_with_known_primes_function(start, end):
    """ Uses known primes up to sqrt(end) to sieve the range [start, end] """


    sieve = [True] * (end - start + 1)

    for prime in primesCopy:
        # Find the first multiple of prime in the [start, end] range
        multiple = max(prime * prime, (start + prime - 1) // prime * prime)

        # Mark off multiples of prime in the sieve array
        for i in range(multiple, end + 1, prime):
            sieve[i - start] = False

    # Return the list of primes in the range [start, end]
    #return [num for num, is_prime in enumerate(sieve, start=start) if is_prime]
    bigNumber = [num for num, is_prime in enumerate(sieve, start=start) if is_prime]
    return bigNumber



nprocs = 16
if (len(sys.argv) > 1):
    nprocs = int(sys.argv[1])


n = int(input("Input n: "))
#n = 1000000000000
startT = time.time()


# assume the primes in the prime triplet are
# not larger than n + 100000
#largestPrimeNeeded = int (math.sqrt(n + 100000))

if (n <= 5):
    msg = 'The smallest triplet larger than ' + str(n) + ' is ('
    msg = msg + '5, 7, 11)'
    print(msg)
    exit()


# assume the primes in the prime triplet are
# not larger than n + 100000
largestPrimeNeeded = int (math.sqrt(n + 100000))


tQueue = multiprocessing.Queue()
rQueue = multiprocessing.Queue()

p = list()
for i in range(0, nprocs):
    p.append(multiprocessing.Process(target=sieve_with_known_primes))

for i in range(0, nprocs):
    p[i].start()

#we're starting at 6 because numbers from -infinity to 5 are accounted for already

mainStart = time.time()
endForMain = int(largestPrimeNeeded/(nprocs + 1))
makePrimeList(endForMain)
mainEnd = time.time()

start = endForMain
totalNumbers = largestPrimeNeeded - start
chunk =  totalNumbers//nprocs
remainder = totalNumbers % nprocs

groups = []
currentStart = start

listStartT = time.time()

for i in range(nprocs):
    groupSize = chunk + (1 if i < remainder else 0)
    #currentEnd = currentStart + groupSize - 1
    currentEnd = currentStart + groupSize + 1

    #i think the line below is what needs to be replaced with the tQueue
    groups.append((currentStart, currentEnd))
    tQueue.put((currentStart, currentEnd))

    currentStart = currentEnd + 1


for i in range(0, nprocs):
    tQueue.put((-1, -1))

for _ in p:
    primesCopy.extend(rQueue.get())



for children in p:
    children.join()

#print(groups)


#makePrimeList(largestPrimeNeeded)
listStopT = time.time()



godStart = time.time()
#somethingBig = sieve_with_known_primes_function(4000000000000, 4000000100000)
somethingBig = sieve_with_known_primes_function(n, n+100000)
godEnd = time.time()

newSearchStart = time.time()


m4 = 2
m5 = 2
m6 = 2

for cur in somethingBig:
    m4,m5,m6 = m5, m6, cur
    if (m6 - m4 == 6):
        msgN = 'The smallest triplet larger than ' + str(n) + ' is ('
        msgN = msgN + str(m4) + ', ' + str(m5)
        msgN = msgN + ', ' + str(m6) + ')'

        print(msgN)
        break;

newSearchEnd = time.time()

stopT = time.time()

print()
print(f"The amount of workers is: {nprocs}")
print(f"the main process took {mainEnd - mainStart} seconds")
print(f'Time to build the list of prime numbers: {listStopT - listStartT} seconds')
print(f"it took {godEnd - godStart} seconds to create the list from {n} to {n+100000}")
print(f"it took the new prime triplet {newSearchEnd - newSearchStart} seconds to finish")
print(f'Total time: {stopT - startT} seconds')
